
FlashProg.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005ee  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001e  00800060  000005ee  00000662  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .debug_aranges 00000020  00000000  00000000  00000680  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000199  00000000  00000000  000006a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000077f  00000000  00000000  00000839  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000002ad  00000000  00000000  00000fb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000799  00000000  00000000  00001265  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000180  00000000  00000000  00001a00  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000237  00000000  00000000  00001b80  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000374  00000000  00000000  00001db7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000030  00000000  00000000  0000212b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	14 c0       	rjmp	.+40     	; 0x2a <__ctors_end>
   2:	26 c0       	rjmp	.+76     	; 0x50 <__bad_interrupt>
   4:	25 c0       	rjmp	.+74     	; 0x50 <__bad_interrupt>
   6:	24 c0       	rjmp	.+72     	; 0x50 <__bad_interrupt>
   8:	23 c0       	rjmp	.+70     	; 0x50 <__bad_interrupt>
   a:	22 c0       	rjmp	.+68     	; 0x50 <__bad_interrupt>
   c:	21 c0       	rjmp	.+66     	; 0x50 <__bad_interrupt>
   e:	20 c0       	rjmp	.+64     	; 0x50 <__bad_interrupt>
  10:	1f c0       	rjmp	.+62     	; 0x50 <__bad_interrupt>
  12:	1e c0       	rjmp	.+60     	; 0x50 <__bad_interrupt>
  14:	1d c0       	rjmp	.+58     	; 0x50 <__bad_interrupt>
  16:	1c c0       	rjmp	.+56     	; 0x50 <__bad_interrupt>
  18:	1b c0       	rjmp	.+54     	; 0x50 <__bad_interrupt>
  1a:	1a c0       	rjmp	.+52     	; 0x50 <__bad_interrupt>
  1c:	19 c0       	rjmp	.+50     	; 0x50 <__bad_interrupt>
  1e:	18 c0       	rjmp	.+48     	; 0x50 <__bad_interrupt>
  20:	17 c0       	rjmp	.+46     	; 0x50 <__bad_interrupt>
  22:	16 c0       	rjmp	.+44     	; 0x50 <__bad_interrupt>
  24:	15 c0       	rjmp	.+42     	; 0x50 <__bad_interrupt>
  26:	14 c0       	rjmp	.+40     	; 0x50 <__bad_interrupt>
  28:	13 c0       	rjmp	.+38     	; 0x50 <__bad_interrupt>

0000002a <__ctors_end>:
  2a:	11 24       	eor	r1, r1
  2c:	1f be       	out	0x3f, r1	; 63
  2e:	cf e5       	ldi	r28, 0x5F	; 95
  30:	d2 e0       	ldi	r29, 0x02	; 2
  32:	de bf       	out	0x3e, r29	; 62
  34:	cd bf       	out	0x3d, r28	; 61

00000036 <__do_copy_data>:
  36:	10 e0       	ldi	r17, 0x00	; 0
  38:	a0 e6       	ldi	r26, 0x60	; 96
  3a:	b0 e0       	ldi	r27, 0x00	; 0
  3c:	ee ee       	ldi	r30, 0xEE	; 238
  3e:	f5 e0       	ldi	r31, 0x05	; 5
  40:	02 c0       	rjmp	.+4      	; 0x46 <.do_copy_data_start>

00000042 <.do_copy_data_loop>:
  42:	05 90       	lpm	r0, Z+
  44:	0d 92       	st	X+, r0

00000046 <.do_copy_data_start>:
  46:	ae 37       	cpi	r26, 0x7E	; 126
  48:	b1 07       	cpc	r27, r17
  4a:	d9 f7       	brne	.-10     	; 0x42 <.do_copy_data_loop>
  4c:	85 d2       	rcall	.+1290   	; 0x558 <main>
  4e:	cd c2       	rjmp	.+1434   	; 0x5ea <_exit>

00000050 <__bad_interrupt>:
  50:	d7 cf       	rjmp	.-82     	; 0x0 <__vectors>

00000052 <serial_read_u32>:

const char *const g_sHex = "0123456789abcdef";


const uint32 serial_read_u32()
{
  52:	ef 92       	push	r14
  54:	ff 92       	push	r15
  56:	0f 93       	push	r16
  58:	1f 93       	push	r17
	uint32 val = 0;

	while(!(UCSRA & (1 << RXC))) ;
  5a:	5f 9b       	sbis	0x0b, 7	; 11
  5c:	fe cf       	rjmp	.-4      	; 0x5a <serial_read_u32+0x8>
	val |= UDR;
  5e:	2c b1       	in	r18, 0x0c	; 12
	val <<= 8;

	while(!(UCSRA & (1 << RXC))) ;
  60:	5f 9b       	sbis	0x0b, 7	; 11
  62:	fe cf       	rjmp	.-4      	; 0x60 <serial_read_u32+0xe>
	val |= UDR;
  64:	8c b1       	in	r24, 0x0c	; 12
	val <<= 8;

	while(!(UCSRA & (1 << RXC))) ;
  66:	5f 9b       	sbis	0x0b, 7	; 11
  68:	fe cf       	rjmp	.-4      	; 0x66 <serial_read_u32+0x14>
	val |= UDR;
  6a:	6c b1       	in	r22, 0x0c	; 12
	val <<= 8;

	while(!(UCSRA & (1 << RXC))) ;
  6c:	5f 9b       	sbis	0x0b, 7	; 11
  6e:	fe cf       	rjmp	.-4      	; 0x6c <serial_read_u32+0x1a>
	val |= UDR;
  70:	ec b0       	in	r14, 0x0c	; 12
{
	uint32 val = 0;

	while(!(UCSRA & (1 << RXC))) ;
	val |= UDR;
	val <<= 8;
  72:	30 e0       	ldi	r19, 0x00	; 0
  74:	40 e0       	ldi	r20, 0x00	; 0
  76:	50 e0       	ldi	r21, 0x00	; 0
  78:	54 2f       	mov	r21, r20
  7a:	43 2f       	mov	r20, r19
  7c:	32 2f       	mov	r19, r18
  7e:	22 27       	eor	r18, r18

	while(!(UCSRA & (1 << RXC))) ;
	val |= UDR;
  80:	90 e0       	ldi	r25, 0x00	; 0
  82:	a0 e0       	ldi	r26, 0x00	; 0
  84:	b0 e0       	ldi	r27, 0x00	; 0
  86:	28 2b       	or	r18, r24
  88:	39 2b       	or	r19, r25
  8a:	4a 2b       	or	r20, r26
  8c:	5b 2b       	or	r21, r27
	val <<= 8;
  8e:	54 2f       	mov	r21, r20
  90:	43 2f       	mov	r20, r19
  92:	32 2f       	mov	r19, r18
  94:	22 27       	eor	r18, r18

	while(!(UCSRA & (1 << RXC))) ;
	val |= UDR;
  96:	86 2f       	mov	r24, r22
  98:	90 e0       	ldi	r25, 0x00	; 0
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b0 e0       	ldi	r27, 0x00	; 0
  9e:	28 2b       	or	r18, r24
  a0:	39 2b       	or	r19, r25
  a2:	4a 2b       	or	r20, r26
  a4:	5b 2b       	or	r21, r27
	val <<= 8;
  a6:	54 2f       	mov	r21, r20
  a8:	43 2f       	mov	r20, r19
  aa:	32 2f       	mov	r19, r18
  ac:	22 27       	eor	r18, r18
  ae:	ff 24       	eor	r15, r15
  b0:	00 e0       	ldi	r16, 0x00	; 0
  b2:	10 e0       	ldi	r17, 0x00	; 0
  b4:	2e 29       	or	r18, r14
  b6:	3f 29       	or	r19, r15
  b8:	40 2b       	or	r20, r16
  ba:	51 2b       	or	r21, r17

	while(!(UCSRA & (1 << RXC))) ;
	val |= UDR;

	return val;
}
  bc:	b9 01       	movw	r22, r18
  be:	ca 01       	movw	r24, r20
  c0:	1f 91       	pop	r17
  c2:	0f 91       	pop	r16
  c4:	ff 90       	pop	r15
  c6:	ef 90       	pop	r14
  c8:	08 95       	ret

000000ca <serial_getc>:


char serial_getc(void)
{
	while(!(UCSRA & (1 << RXC))) ;
  ca:	5f 9b       	sbis	0x0b, 7	; 11
  cc:	fe cf       	rjmp	.-4      	; 0xca <serial_getc>
	return UDR;
  ce:	8c b1       	in	r24, 0x0c	; 12
}
  d0:	08 95       	ret

000000d2 <serial_putc>:


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
  d2:	5d 9b       	sbis	0x0b, 5	; 11
  d4:	fe cf       	rjmp	.-4      	; 0xd2 <serial_putc>
	UDR = c;
  d6:	8c b9       	out	0x0c, r24	; 12
}
  d8:	08 95       	ret

000000da <serial_puthex8>:


void serial_puthex8(const uint8 u)
{
  da:	98 2f       	mov	r25, r24
	while(!(UCSRA & (1 << UDRE))) ;
  dc:	5d 9b       	sbis	0x0b, 5	; 11
  de:	fe cf       	rjmp	.-4      	; 0xdc <serial_puthex8+0x2>
	UDR = g_sHex[u >> 4];
  e0:	e9 2f       	mov	r30, r25
  e2:	e2 95       	swap	r30
  e4:	ef 70       	andi	r30, 0x0F	; 15
  e6:	f0 e0       	ldi	r31, 0x00	; 0
  e8:	e0 5a       	subi	r30, 0xA0	; 160
  ea:	ff 4f       	sbci	r31, 0xFF	; 255
  ec:	80 81       	ld	r24, Z
  ee:	8c b9       	out	0x0c, r24	; 12

	while(!(UCSRA & (1 << UDRE))) ;
  f0:	5d 9b       	sbis	0x0b, 5	; 11
  f2:	fe cf       	rjmp	.-4      	; 0xf0 <serial_puthex8+0x16>
	UDR = g_sHex[u & 0xf];
  f4:	e9 2f       	mov	r30, r25
  f6:	f0 e0       	ldi	r31, 0x00	; 0
  f8:	ef 70       	andi	r30, 0x0F	; 15
  fa:	f0 70       	andi	r31, 0x00	; 0
  fc:	e0 5a       	subi	r30, 0xA0	; 160
  fe:	ff 4f       	sbci	r31, 0xFF	; 255
 100:	80 81       	ld	r24, Z
 102:	8c b9       	out	0x0c, r24	; 12
}
 104:	08 95       	ret

00000106 <serial_puts>:


void serial_puts(const char *s)
{
 106:	fc 01       	movw	r30, r24
 108:	04 c0       	rjmp	.+8      	; 0x112 <serial_puts+0xc>
	while(*s)
	{
		while(!(UCSRA & (1 << UDRE))) ;
 10a:	5d 9b       	sbis	0x0b, 5	; 11
 10c:	fe cf       	rjmp	.-4      	; 0x10a <serial_puts+0x4>
		UDR = *s++;
 10e:	8c b9       	out	0x0c, r24	; 12
 110:	31 96       	adiw	r30, 0x01	; 1
}


void serial_puts(const char *s)
{
	while(*s)
 112:	80 81       	ld	r24, Z
 114:	88 23       	and	r24, r24
 116:	c9 f7       	brne	.-14     	; 0x10a <serial_puts+0x4>
	{
		while(!(UCSRA & (1 << UDRE))) ;
		UDR = *s++;
	}
}
 118:	08 95       	ret

0000011a <serial_write>:


void serial_write(const char *s, int len)
{
 11a:	fc 01       	movw	r30, r24
 11c:	04 c0       	rjmp	.+8      	; 0x126 <serial_write+0xc>
	while(len--)
	{
		while(!(UCSRA & (1 << UDRE))) ;
 11e:	5d 9b       	sbis	0x0b, 5	; 11
 120:	fe cf       	rjmp	.-4      	; 0x11e <serial_write+0x4>
		UDR = *s++;
 122:	81 91       	ld	r24, Z+
 124:	8c b9       	out	0x0c, r24	; 12
}


void serial_write(const char *s, int len)
{
	while(len--)
 126:	61 50       	subi	r22, 0x01	; 1
 128:	70 40       	sbci	r23, 0x00	; 0
 12a:	8f ef       	ldi	r24, 0xFF	; 255
 12c:	6f 3f       	cpi	r22, 0xFF	; 255
 12e:	78 07       	cpc	r23, r24
 130:	b1 f7       	brne	.-20     	; 0x11e <serial_write+0x4>
	{
		while(!(UCSRA & (1 << UDRE))) ;
		UDR = *s++;
	}
}
 132:	08 95       	ret

00000134 <report_status>:
}


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
 134:	5d 9b       	sbis	0x0b, 5	; 11
 136:	fe cf       	rjmp	.-4      	; 0x134 <report_status>
	UDR = c;
 138:	8c b9       	out	0x0c, r24	; 12
 13a:	90 e0       	ldi	r25, 0x00	; 0
 13c:	8a 35       	cpi	r24, 0x5A	; 90
 13e:	09 f0       	breq	.+2      	; 0x142 <report_status+0xe>
 140:	91 e0       	ldi	r25, 0x01	; 1

uint8 report_status(const uint8 err)
{
	serial_putc(err);
	return (err == ERR_OK) ? 0 : 1;
}
 142:	89 2f       	mov	r24, r25
 144:	08 95       	ret

00000146 <bus_init>:


void bus_init(void)
{
	// Negate nCE, nOE and nWE before the control lines become outputs
	PORTD = nCE | nOE | nWE;
 146:	80 ee       	ldi	r24, 0xE0	; 224
 148:	82 bb       	out	0x12, r24	; 18

	// Configure data direction register
	DDRA = 0xff;		// Port A:  D0-D7 - all outputs initially
 14a:	8f ef       	ldi	r24, 0xFF	; 255
 14c:	8a bb       	out	0x1a, r24	; 26
	DDRB = 0xff;		// Port B:  A0-A7 - all outputs
 14e:	87 bb       	out	0x17, r24	; 23
	DDRC = 0xff;		// Port C:  A8-A15 - all outputs
 150:	84 bb       	out	0x14, r24	; 20
	DDRD = 0xfe;		// Port D:  pd0 input (serial RX) , pd1-pd7 outputs (serial TX, control lines)
 152:	8e ef       	ldi	r24, 0xFE	; 254
 154:	81 bb       	out	0x11, r24	; 17
}
 156:	08 95       	ret

00000158 <data_read>:

const unsigned char data_read(const uint32 address)
{
	uint8 data;

	PORTB = address >> 16;
 158:	9c 01       	movw	r18, r24
 15a:	44 27       	eor	r20, r20
 15c:	55 27       	eor	r21, r21
 15e:	28 bb       	out	0x18, r18	; 24
	PORTD |= CLK;
 160:	94 9a       	sbi	0x12, 4	; 18
	PORTD &= ~CLK;
 162:	94 98       	cbi	0x12, 4	; 18

	PORTC = address >> 8;
 164:	27 2f       	mov	r18, r23
 166:	38 2f       	mov	r19, r24
 168:	49 2f       	mov	r20, r25
 16a:	55 27       	eor	r21, r21
 16c:	25 bb       	out	0x15, r18	; 21
	PORTB = address & 0xff;
 16e:	68 bb       	out	0x18, r22	; 24

	DDRA = 0x00;	// port A -> inputs
 170:	1a ba       	out	0x1a, r1	; 26
	PORTD &= ~nOE;	// assert nOE
 172:	96 98       	cbi	0x12, 6	; 18
	nop();
 174:	00 00       	nop

	data = PINA;	// read data
 176:	89 b3       	in	r24, 0x19	; 25

	PORTD |= nOE;	// negate nOE and nCE
 178:	96 9a       	sbi	0x12, 6	; 18
	DDRA = 0xff;	// port A -> outputs
 17a:	9f ef       	ldi	r25, 0xFF	; 255
 17c:	9a bb       	out	0x1a, r25	; 26

	return data;
}
 17e:	08 95       	ret

00000180 <data_write>:


void data_write(const uint32 address, const uint8 data)
{
 180:	0f 93       	push	r16
 182:	1f 93       	push	r17
	PORTB = address >> 16;
 184:	8c 01       	movw	r16, r24
 186:	22 27       	eor	r18, r18
 188:	33 27       	eor	r19, r19
 18a:	08 bb       	out	0x18, r16	; 24
	PORTD |= CLK;
 18c:	94 9a       	sbi	0x12, 4	; 18
	PORTD &= ~CLK;
 18e:	94 98       	cbi	0x12, 4	; 18

	PORTC = address >> 8;
 190:	07 2f       	mov	r16, r23
 192:	18 2f       	mov	r17, r24
 194:	29 2f       	mov	r18, r25
 196:	33 27       	eor	r19, r19
 198:	05 bb       	out	0x15, r16	; 21
	PORTB = address & 0xff;
 19a:	68 bb       	out	0x18, r22	; 24

	PORTA = data;
 19c:	4b bb       	out	0x1b, r20	; 27

	PORTD &= ~nWE;
 19e:	97 98       	cbi	0x12, 7	; 18
	PORTD |= nWE;
 1a0:	97 9a       	sbi	0x12, 7	; 18
}
 1a2:	1f 91       	pop	r17
 1a4:	0f 91       	pop	r16
 1a6:	08 95       	ret

000001a8 <wait>:


const uint8 wait(const uint32 address, uint8 data)
{
 1a8:	ef 92       	push	r14
 1aa:	ff 92       	push	r15
 1ac:	0f 93       	push	r16
 1ae:	1f 93       	push	r17
 1b0:	cf 93       	push	r28
 1b2:	df 93       	push	r29
 1b4:	7b 01       	movw	r14, r22
 1b6:	8c 01       	movw	r16, r24
	uint8 status;
	data &= 0x80;
 1b8:	40 78       	andi	r20, 0x80	; 128
//		if((status & 0xa0) == 0x20)
//		{
//			data_write(0, 0xf0);		// reset device
//			return ERR_TIMEOUT;
//		}
	} while((status & 0x80) != data);
 1ba:	c4 2f       	mov	r28, r20
 1bc:	d0 e0       	ldi	r29, 0x00	; 0
	uint8 status;
	data &= 0x80;

	do
	{
		status = data_read(address);
 1be:	c8 01       	movw	r24, r16
 1c0:	b7 01       	movw	r22, r14
 1c2:	ca df       	rcall	.-108    	; 0x158 <data_read>
//		if((status & 0xa0) == 0x20)
//		{
//			data_write(0, 0xf0);		// reset device
//			return ERR_TIMEOUT;
//		}
	} while((status & 0x80) != data);
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	80 78       	andi	r24, 0x80	; 128
 1c8:	90 70       	andi	r25, 0x00	; 0
 1ca:	8c 17       	cp	r24, r28
 1cc:	9d 07       	cpc	r25, r29
 1ce:	b9 f7       	brne	.-18     	; 0x1be <wait+0x16>


	return ERR_OK;
}
 1d0:	8a e5       	ldi	r24, 0x5A	; 90
 1d2:	df 91       	pop	r29
 1d4:	cf 91       	pop	r28
 1d6:	1f 91       	pop	r17
 1d8:	0f 91       	pop	r16
 1da:	ff 90       	pop	r15
 1dc:	ef 90       	pop	r14
 1de:	08 95       	ret

000001e0 <autoselect>:


const uint8 autoselect(const uint32 address)
{
 1e0:	ef 92       	push	r14
 1e2:	ff 92       	push	r15
 1e4:	0f 93       	push	r16
 1e6:	1f 93       	push	r17
 1e8:	7b 01       	movw	r14, r22
 1ea:	8c 01       	movw	r16, r24
}


inline void chip_enable(void)
{
	PORTD |= RED;
 1ec:	92 9a       	sbi	0x12, 2	; 18
	PORTD &= ~nCE;
 1ee:	95 98       	cbi	0x12, 5	; 18
{
	uint8 data;

	chip_enable();

	data_write(0x555, 0xaa);
 1f0:	65 e5       	ldi	r22, 0x55	; 85
 1f2:	75 e0       	ldi	r23, 0x05	; 5
 1f4:	80 e0       	ldi	r24, 0x00	; 0
 1f6:	90 e0       	ldi	r25, 0x00	; 0
 1f8:	4a ea       	ldi	r20, 0xAA	; 170
 1fa:	c2 df       	rcall	.-124    	; 0x180 <data_write>
	data_write(0x2aa, 0x55);
 1fc:	6a ea       	ldi	r22, 0xAA	; 170
 1fe:	72 e0       	ldi	r23, 0x02	; 2
 200:	80 e0       	ldi	r24, 0x00	; 0
 202:	90 e0       	ldi	r25, 0x00	; 0
 204:	45 e5       	ldi	r20, 0x55	; 85
 206:	bc df       	rcall	.-136    	; 0x180 <data_write>
	data_write(0x555, 0x90);
 208:	65 e5       	ldi	r22, 0x55	; 85
 20a:	75 e0       	ldi	r23, 0x05	; 5
 20c:	80 e0       	ldi	r24, 0x00	; 0
 20e:	90 e0       	ldi	r25, 0x00	; 0
 210:	40 e9       	ldi	r20, 0x90	; 144
 212:	b6 df       	rcall	.-148    	; 0x180 <data_write>

	data = data_read(address);
 214:	c8 01       	movw	r24, r16
 216:	b7 01       	movw	r22, r14
 218:	9f df       	rcall	.-194    	; 0x158 <data_read>
 21a:	18 2f       	mov	r17, r24

	data_write(0, 0xf0);		// reset device
 21c:	60 e0       	ldi	r22, 0x00	; 0
 21e:	70 e0       	ldi	r23, 0x00	; 0
 220:	80 e0       	ldi	r24, 0x00	; 0
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	40 ef       	ldi	r20, 0xF0	; 240
 226:	ac df       	rcall	.-168    	; 0x180 <data_write>
}


inline void chip_disable(void)
{
	PORTD |= nCE;
 228:	95 9a       	sbi	0x12, 5	; 18
	PORTD &= ~RED;
 22a:	92 98       	cbi	0x12, 2	; 18
	data_write(0, 0xf0);		// reset device

	chip_disable();

	return data;
}
 22c:	81 2f       	mov	r24, r17
 22e:	1f 91       	pop	r17
 230:	0f 91       	pop	r16
 232:	ff 90       	pop	r15
 234:	ef 90       	pop	r14
 236:	08 95       	ret

00000238 <get_manufacturer_id>:


const uint8 get_manufacturer_id()
{
	return autoselect(0);
 238:	60 e0       	ldi	r22, 0x00	; 0
 23a:	70 e0       	ldi	r23, 0x00	; 0
 23c:	80 e0       	ldi	r24, 0x00	; 0
 23e:	90 e0       	ldi	r25, 0x00	; 0
 240:	cf df       	rcall	.-98     	; 0x1e0 <autoselect>
}
 242:	08 95       	ret

00000244 <get_device_id>:


const uint8 get_device_id()
{
	return autoselect(1);
 244:	61 e0       	ldi	r22, 0x01	; 1
 246:	70 e0       	ldi	r23, 0x00	; 0
 248:	80 e0       	ldi	r24, 0x00	; 0
 24a:	90 e0       	ldi	r25, 0x00	; 0
 24c:	c9 df       	rcall	.-110    	; 0x1e0 <autoselect>
}
 24e:	08 95       	ret

00000250 <get_continuation_id>:


const uint8 get_continuation_id()
{
	return autoselect(3);
 250:	63 e0       	ldi	r22, 0x03	; 3
 252:	70 e0       	ldi	r23, 0x00	; 0
 254:	80 e0       	ldi	r24, 0x00	; 0
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	c3 df       	rcall	.-122    	; 0x1e0 <autoselect>
}
 25a:	08 95       	ret

0000025c <get_sector_protect>:


const uint8 get_sector_protect(const uint8 sector)
{
	return autoselect(((uint32) (sector & 0x7) << 16) | 0x2);
 25c:	90 e0       	ldi	r25, 0x00	; 0
 25e:	a0 e0       	ldi	r26, 0x00	; 0
 260:	b0 e0       	ldi	r27, 0x00	; 0
 262:	87 70       	andi	r24, 0x07	; 7
 264:	90 70       	andi	r25, 0x00	; 0
 266:	a0 70       	andi	r26, 0x00	; 0
 268:	b0 70       	andi	r27, 0x00	; 0
 26a:	dc 01       	movw	r26, r24
 26c:	99 27       	eor	r25, r25
 26e:	88 27       	eor	r24, r24
 270:	82 60       	ori	r24, 0x02	; 2
 272:	bc 01       	movw	r22, r24
 274:	cd 01       	movw	r24, r26
 276:	b4 df       	rcall	.-152    	; 0x1e0 <autoselect>
}
 278:	08 95       	ret

0000027a <chip_id>:


const uint8 chip_id()
{
	serial_putc(get_manufacturer_id());
 27a:	de df       	rcall	.-68     	; 0x238 <get_manufacturer_id>
}


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
 27c:	5d 9b       	sbis	0x0b, 5	; 11
 27e:	fe cf       	rjmp	.-4      	; 0x27c <chip_id+0x2>
	UDR = c;
 280:	8c b9       	out	0x0c, r24	; 12


const uint8 chip_id()
{
	serial_putc(get_manufacturer_id());
	serial_putc(get_device_id());
 282:	e0 df       	rcall	.-64     	; 0x244 <get_device_id>
}


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
 284:	5d 9b       	sbis	0x0b, 5	; 11
 286:	fe cf       	rjmp	.-4      	; 0x284 <chip_id+0xa>
	UDR = c;
 288:	8c b9       	out	0x0c, r24	; 12

const uint8 chip_id()
{
	serial_putc(get_manufacturer_id());
	serial_putc(get_device_id());
	serial_putc(get_continuation_id());
 28a:	e2 df       	rcall	.-60     	; 0x250 <get_continuation_id>
}


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
 28c:	5d 9b       	sbis	0x0b, 5	; 11
 28e:	fe cf       	rjmp	.-4      	; 0x28c <chip_id+0x12>
	UDR = c;
 290:	8c b9       	out	0x0c, r24	; 12
}


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
 292:	5d 9b       	sbis	0x0b, 5	; 11
 294:	fe cf       	rjmp	.-4      	; 0x292 <chip_id+0x18>
	UDR = c;
 296:	1c b8       	out	0x0c, r1	; 12
	serial_putc(get_device_id());
	serial_putc(get_continuation_id());
	serial_putc(0x00);

	return ERR_OK;
}
 298:	8a e5       	ldi	r24, 0x5A	; 90
 29a:	08 95       	ret

0000029c <chip_erase>:
}


inline void chip_enable(void)
{
	PORTD |= RED;
 29c:	92 9a       	sbi	0x12, 2	; 18
	PORTD &= ~nCE;
 29e:	95 98       	cbi	0x12, 5	; 18
{
	uint8 result;

	chip_enable();

	data_write(0x555, 0xaa);
 2a0:	65 e5       	ldi	r22, 0x55	; 85
 2a2:	75 e0       	ldi	r23, 0x05	; 5
 2a4:	80 e0       	ldi	r24, 0x00	; 0
 2a6:	90 e0       	ldi	r25, 0x00	; 0
 2a8:	4a ea       	ldi	r20, 0xAA	; 170
 2aa:	6a df       	rcall	.-300    	; 0x180 <data_write>
	data_write(0x2aa, 0x55);
 2ac:	6a ea       	ldi	r22, 0xAA	; 170
 2ae:	72 e0       	ldi	r23, 0x02	; 2
 2b0:	80 e0       	ldi	r24, 0x00	; 0
 2b2:	90 e0       	ldi	r25, 0x00	; 0
 2b4:	45 e5       	ldi	r20, 0x55	; 85
 2b6:	64 df       	rcall	.-312    	; 0x180 <data_write>
	data_write(0x555, 0x80);
 2b8:	65 e5       	ldi	r22, 0x55	; 85
 2ba:	75 e0       	ldi	r23, 0x05	; 5
 2bc:	80 e0       	ldi	r24, 0x00	; 0
 2be:	90 e0       	ldi	r25, 0x00	; 0
 2c0:	40 e8       	ldi	r20, 0x80	; 128
 2c2:	5e df       	rcall	.-324    	; 0x180 <data_write>
	data_write(0x555, 0xaa);
 2c4:	65 e5       	ldi	r22, 0x55	; 85
 2c6:	75 e0       	ldi	r23, 0x05	; 5
 2c8:	80 e0       	ldi	r24, 0x00	; 0
 2ca:	90 e0       	ldi	r25, 0x00	; 0
 2cc:	4a ea       	ldi	r20, 0xAA	; 170
 2ce:	58 df       	rcall	.-336    	; 0x180 <data_write>
	data_write(0x2aa, 0x55);
 2d0:	6a ea       	ldi	r22, 0xAA	; 170
 2d2:	72 e0       	ldi	r23, 0x02	; 2
 2d4:	80 e0       	ldi	r24, 0x00	; 0
 2d6:	90 e0       	ldi	r25, 0x00	; 0
 2d8:	45 e5       	ldi	r20, 0x55	; 85
 2da:	52 df       	rcall	.-348    	; 0x180 <data_write>
	data_write(0x555, 0x10);
 2dc:	65 e5       	ldi	r22, 0x55	; 85
 2de:	75 e0       	ldi	r23, 0x05	; 5
 2e0:	80 e0       	ldi	r24, 0x00	; 0
 2e2:	90 e0       	ldi	r25, 0x00	; 0
 2e4:	40 e1       	ldi	r20, 0x10	; 16
 2e6:	4c df       	rcall	.-360    	; 0x180 <data_write>

	result = wait(0, 0x80);
 2e8:	60 e0       	ldi	r22, 0x00	; 0
 2ea:	70 e0       	ldi	r23, 0x00	; 0
 2ec:	80 e0       	ldi	r24, 0x00	; 0
 2ee:	90 e0       	ldi	r25, 0x00	; 0
 2f0:	40 e8       	ldi	r20, 0x80	; 128
 2f2:	5a df       	rcall	.-332    	; 0x1a8 <wait>
}


inline void chip_disable(void)
{
	PORTD |= nCE;
 2f4:	95 9a       	sbi	0x12, 5	; 18
	PORTD &= ~RED;
 2f6:	92 98       	cbi	0x12, 2	; 18
	result = wait(0, 0x80);

	chip_disable();

	return result;
}
 2f8:	08 95       	ret

000002fa <sector_erase>:


const uint8 sector_erase(void)
{
 2fa:	ef 92       	push	r14
 2fc:	ff 92       	push	r15
 2fe:	0f 93       	push	r16
 300:	1f 93       	push	r17
}


char serial_getc(void)
{
	while(!(UCSRA & (1 << RXC))) ;
 302:	5f 9b       	sbis	0x0b, 7	; 11
 304:	fe cf       	rjmp	.-4      	; 0x302 <sector_erase+0x8>
	return UDR;
 306:	1c b1       	in	r17, 0x0c	; 12

const uint8 sector_erase(void)
{
	uint8 result, sector;

	sector = serial_getc() - '0';
 308:	10 53       	subi	r17, 0x30	; 48
	if(sector > 7)
 30a:	18 30       	cpi	r17, 0x08	; 8
 30c:	10 f0       	brcs	.+4      	; 0x312 <sector_erase+0x18>
 30e:	81 e0       	ldi	r24, 0x01	; 1
 310:	31 c0       	rjmp	.+98     	; 0x374 <sector_erase+0x7a>
}


inline void chip_enable(void)
{
	PORTD |= RED;
 312:	92 9a       	sbi	0x12, 2	; 18
	PORTD &= ~nCE;
 314:	95 98       	cbi	0x12, 5	; 18
	if(sector > 7)
		return 1;

	chip_enable();

	data_write(0x555, 0xaa);
 316:	65 e5       	ldi	r22, 0x55	; 85
 318:	75 e0       	ldi	r23, 0x05	; 5
 31a:	80 e0       	ldi	r24, 0x00	; 0
 31c:	90 e0       	ldi	r25, 0x00	; 0
 31e:	4a ea       	ldi	r20, 0xAA	; 170
 320:	2f df       	rcall	.-418    	; 0x180 <data_write>
	data_write(0x2aa, 0x55);
 322:	6a ea       	ldi	r22, 0xAA	; 170
 324:	72 e0       	ldi	r23, 0x02	; 2
 326:	80 e0       	ldi	r24, 0x00	; 0
 328:	90 e0       	ldi	r25, 0x00	; 0
 32a:	45 e5       	ldi	r20, 0x55	; 85
 32c:	29 df       	rcall	.-430    	; 0x180 <data_write>
	data_write(0x555, 0x80);
 32e:	65 e5       	ldi	r22, 0x55	; 85
 330:	75 e0       	ldi	r23, 0x05	; 5
 332:	80 e0       	ldi	r24, 0x00	; 0
 334:	90 e0       	ldi	r25, 0x00	; 0
 336:	40 e8       	ldi	r20, 0x80	; 128
 338:	23 df       	rcall	.-442    	; 0x180 <data_write>
	data_write(0x555, 0xaa);
 33a:	65 e5       	ldi	r22, 0x55	; 85
 33c:	75 e0       	ldi	r23, 0x05	; 5
 33e:	80 e0       	ldi	r24, 0x00	; 0
 340:	90 e0       	ldi	r25, 0x00	; 0
 342:	4a ea       	ldi	r20, 0xAA	; 170
 344:	1d df       	rcall	.-454    	; 0x180 <data_write>
	data_write(0x2aa, 0x55);
 346:	6a ea       	ldi	r22, 0xAA	; 170
 348:	72 e0       	ldi	r23, 0x02	; 2
 34a:	80 e0       	ldi	r24, 0x00	; 0
 34c:	90 e0       	ldi	r25, 0x00	; 0
 34e:	45 e5       	ldi	r20, 0x55	; 85
 350:	17 df       	rcall	.-466    	; 0x180 <data_write>
	data_write((uint32) sector << 16, 0x30);
 352:	e1 2e       	mov	r14, r17
 354:	ff 24       	eor	r15, r15
 356:	00 e0       	ldi	r16, 0x00	; 0
 358:	10 e0       	ldi	r17, 0x00	; 0
 35a:	87 01       	movw	r16, r14
 35c:	ff 24       	eor	r15, r15
 35e:	ee 24       	eor	r14, r14
 360:	c8 01       	movw	r24, r16
 362:	b7 01       	movw	r22, r14
 364:	40 e3       	ldi	r20, 0x30	; 48
 366:	0c df       	rcall	.-488    	; 0x180 <data_write>

	result = wait((uint32) sector << 16, 0x80);
 368:	c8 01       	movw	r24, r16
 36a:	b7 01       	movw	r22, r14
 36c:	40 e8       	ldi	r20, 0x80	; 128
 36e:	1c df       	rcall	.-456    	; 0x1a8 <wait>
}


inline void chip_disable(void)
{
	PORTD |= nCE;
 370:	95 9a       	sbi	0x12, 5	; 18
	PORTD &= ~RED;
 372:	92 98       	cbi	0x12, 2	; 18
	result = wait((uint32) sector << 16, 0x80);

	chip_disable();

	return result;
}
 374:	1f 91       	pop	r17
 376:	0f 91       	pop	r16
 378:	ff 90       	pop	r15
 37a:	ef 90       	pop	r14
 37c:	08 95       	ret

0000037e <program_byte>:


const uint8 program_byte(const uint32 address, const uint8 data)
{
 37e:	df 92       	push	r13
 380:	ef 92       	push	r14
 382:	ff 92       	push	r15
 384:	0f 93       	push	r16
 386:	1f 93       	push	r17
 388:	7b 01       	movw	r14, r22
 38a:	8c 01       	movw	r16, r24
 38c:	d4 2e       	mov	r13, r20
}


inline void chip_enable(void)
{
	PORTD |= RED;
 38e:	92 9a       	sbi	0x12, 2	; 18
	PORTD &= ~nCE;
 390:	95 98       	cbi	0x12, 5	; 18
{
	uint8 result;

	chip_enable();

	data_write(0x555, 0xaa);
 392:	65 e5       	ldi	r22, 0x55	; 85
 394:	75 e0       	ldi	r23, 0x05	; 5
 396:	80 e0       	ldi	r24, 0x00	; 0
 398:	90 e0       	ldi	r25, 0x00	; 0
 39a:	4a ea       	ldi	r20, 0xAA	; 170
 39c:	f1 de       	rcall	.-542    	; 0x180 <data_write>
	data_write(0x2aa, 0x55);
 39e:	6a ea       	ldi	r22, 0xAA	; 170
 3a0:	72 e0       	ldi	r23, 0x02	; 2
 3a2:	80 e0       	ldi	r24, 0x00	; 0
 3a4:	90 e0       	ldi	r25, 0x00	; 0
 3a6:	45 e5       	ldi	r20, 0x55	; 85
 3a8:	eb de       	rcall	.-554    	; 0x180 <data_write>
	data_write(0x555, 0xa0);
 3aa:	65 e5       	ldi	r22, 0x55	; 85
 3ac:	75 e0       	ldi	r23, 0x05	; 5
 3ae:	80 e0       	ldi	r24, 0x00	; 0
 3b0:	90 e0       	ldi	r25, 0x00	; 0
 3b2:	40 ea       	ldi	r20, 0xA0	; 160
 3b4:	e5 de       	rcall	.-566    	; 0x180 <data_write>

	data_write(address, data);
 3b6:	c8 01       	movw	r24, r16
 3b8:	b7 01       	movw	r22, r14
 3ba:	4d 2d       	mov	r20, r13
 3bc:	e1 de       	rcall	.-574    	; 0x180 <data_write>

	result = wait(address, data);
 3be:	c8 01       	movw	r24, r16
 3c0:	b7 01       	movw	r22, r14
 3c2:	4d 2d       	mov	r20, r13
 3c4:	f1 de       	rcall	.-542    	; 0x1a8 <wait>
}


inline void chip_disable(void)
{
	PORTD |= nCE;
 3c6:	95 9a       	sbi	0x12, 5	; 18
	PORTD &= ~RED;
 3c8:	92 98       	cbi	0x12, 2	; 18
	result = wait(address, data);

	chip_disable();

	return result;
}
 3ca:	1f 91       	pop	r17
 3cc:	0f 91       	pop	r16
 3ce:	ff 90       	pop	r15
 3d0:	ef 90       	pop	r14
 3d2:	df 90       	pop	r13
 3d4:	08 95       	ret

000003d6 <block_program>:


const uint8 block_program()
{
 3d6:	2f 92       	push	r2
 3d8:	3f 92       	push	r3
 3da:	4f 92       	push	r4
 3dc:	5f 92       	push	r5
 3de:	6f 92       	push	r6
 3e0:	7f 92       	push	r7
 3e2:	8f 92       	push	r8
 3e4:	9f 92       	push	r9
 3e6:	af 92       	push	r10
 3e8:	bf 92       	push	r11
 3ea:	cf 92       	push	r12
 3ec:	df 92       	push	r13
 3ee:	ef 92       	push	r14
 3f0:	ff 92       	push	r15
 3f2:	0f 93       	push	r16
 3f4:	1f 93       	push	r17
 3f6:	df 93       	push	r29
 3f8:	cf 93       	push	r28
 3fa:	cd b7       	in	r28, 0x3d	; 61
 3fc:	de b7       	in	r29, 0x3e	; 62
 3fe:	c0 50       	subi	r28, 0x00	; 0
 400:	d1 40       	sbci	r29, 0x01	; 1
 402:	0f b6       	in	r0, 0x3f	; 63
 404:	f8 94       	cli
 406:	de bf       	out	0x3e, r29	; 62
 408:	0f be       	out	0x3f, r0	; 63
 40a:	cd bf       	out	0x3d, r28	; 61
	uint8 result, buffer[256];
	uint32 i;
	uint32 offset, checksum_read, checksum_local;

	// read offset (address >> 8)
	offset = serial_read_u32();
 40c:	22 de       	rcall	.-956    	; 0x52 <serial_read_u32>
 40e:	5b 01       	movw	r10, r22
 410:	6c 01       	movw	r12, r24
 412:	2e 01       	movw	r4, r28
 414:	08 94       	sec
 416:	41 1c       	adc	r4, r1
 418:	51 1c       	adc	r5, r1
 41a:	12 01       	movw	r2, r4
 41c:	ee 24       	eor	r14, r14
 41e:	ff 24       	eor	r15, r15
 420:	87 01       	movw	r16, r14

	// read 256 bytes
	checksum_local = 0;
	for(i = 0; i <= 255; ++i)
 422:	9e 01       	movw	r18, r28
 424:	2f 5f       	subi	r18, 0xFF	; 255
 426:	3e 4f       	sbci	r19, 0xFE	; 254
}


char serial_getc(void)
{
	while(!(UCSRA & (1 << RXC))) ;
 428:	5f 9b       	sbis	0x0b, 7	; 11
 42a:	fe cf       	rjmp	.-4      	; 0x428 <block_program+0x52>
	return UDR;
 42c:	8c b1       	in	r24, 0x0c	; 12

	// read 256 bytes
	checksum_local = 0;
	for(i = 0; i <= 255; ++i)
	{
		buffer[i] = serial_getc();
 42e:	f1 01       	movw	r30, r2
 430:	81 93       	st	Z+, r24
 432:	1f 01       	movw	r2, r30
		checksum_local += buffer[i];
 434:	e8 0e       	add	r14, r24
 436:	f1 1c       	adc	r15, r1
 438:	01 1d       	adc	r16, r1
 43a:	11 1d       	adc	r17, r1
	// read offset (address >> 8)
	offset = serial_read_u32();

	// read 256 bytes
	checksum_local = 0;
	for(i = 0; i <= 255; ++i)
 43c:	e2 17       	cp	r30, r18
 43e:	f3 07       	cpc	r31, r19
 440:	99 f7       	brne	.-26     	; 0x428 <block_program+0x52>
		buffer[i] = serial_getc();
		checksum_local += buffer[i];
	}

	// read checksum
	checksum_read = serial_read_u32();
 442:	07 de       	rcall	.-1010   	; 0x52 <serial_read_u32>

	// checksum OK?
	if(checksum_read != checksum_local)
 444:	6e 15       	cp	r22, r14
 446:	7f 05       	cpc	r23, r15
 448:	80 07       	cpc	r24, r16
 44a:	91 07       	cpc	r25, r17
 44c:	11 f0       	breq	.+4      	; 0x452 <block_program+0x7c>
 44e:	83 e4       	ldi	r24, 0x43	; 67
 450:	32 c0       	rjmp	.+100    	; 0x4b6 <block_program+0xe0>
}


inline void chip_enable(void)
{
	PORTD |= RED;
 452:	92 9a       	sbi	0x12, 2	; 18
	PORTD &= ~nCE;
 454:	95 98       	cbi	0x12, 5	; 18
	chip_enable();

	// program block
	for(i = 0; i <= 255; ++i)
	{
		data_write(0x555, 0xaa);
 456:	65 e5       	ldi	r22, 0x55	; 85
 458:	75 e0       	ldi	r23, 0x05	; 5
 45a:	80 e0       	ldi	r24, 0x00	; 0
 45c:	90 e0       	ldi	r25, 0x00	; 0
 45e:	4a ea       	ldi	r20, 0xAA	; 170
 460:	8f de       	rcall	.-738    	; 0x180 <data_write>
		data_write(0x2aa, 0x55);
 462:	6a ea       	ldi	r22, 0xAA	; 170
 464:	72 e0       	ldi	r23, 0x02	; 2
 466:	80 e0       	ldi	r24, 0x00	; 0
 468:	90 e0       	ldi	r25, 0x00	; 0
 46a:	45 e5       	ldi	r20, 0x55	; 85
 46c:	89 de       	rcall	.-750    	; 0x180 <data_write>
		data_write(0x555, 0xa0);
 46e:	65 e5       	ldi	r22, 0x55	; 85
 470:	75 e0       	ldi	r23, 0x05	; 5
 472:	80 e0       	ldi	r24, 0x00	; 0
 474:	90 e0       	ldi	r25, 0x00	; 0
 476:	40 ea       	ldi	r20, 0xA0	; 160
 478:	83 de       	rcall	.-762    	; 0x180 <data_write>
		data_write(offset, buffer[i]);
 47a:	f2 01       	movw	r30, r4
 47c:	10 81       	ld	r17, Z
 47e:	c6 01       	movw	r24, r12
 480:	b5 01       	movw	r22, r10
 482:	41 2f       	mov	r20, r17
 484:	7d de       	rcall	.-774    	; 0x180 <data_write>

		result = wait(offset++, buffer[i]);
 486:	35 01       	movw	r6, r10
 488:	46 01       	movw	r8, r12
 48a:	08 94       	sec
 48c:	61 1c       	adc	r6, r1
 48e:	71 1c       	adc	r7, r1
 490:	81 1c       	adc	r8, r1
 492:	91 1c       	adc	r9, r1
 494:	c6 01       	movw	r24, r12
 496:	b5 01       	movw	r22, r10
 498:	41 2f       	mov	r20, r17
 49a:	86 de       	rcall	.-756    	; 0x1a8 <wait>
		if(result != ERR_OK)
 49c:	8a 35       	cpi	r24, 0x5A	; 90
 49e:	49 f4       	brne	.+18     	; 0x4b2 <block_program+0xdc>
		{
			chip_disable();
			return result;
 4a0:	08 94       	sec
 4a2:	41 1c       	adc	r4, r1
 4a4:	51 1c       	adc	r5, r1
		return ERR_BAD_CHECKSUM;

	chip_enable();

	// program block
	for(i = 0; i <= 255; ++i)
 4a6:	42 14       	cp	r4, r2
 4a8:	53 04       	cpc	r5, r3
 4aa:	19 f0       	breq	.+6      	; 0x4b2 <block_program+0xdc>
 4ac:	64 01       	movw	r12, r8
 4ae:	53 01       	movw	r10, r6
 4b0:	d2 cf       	rjmp	.-92     	; 0x456 <block_program+0x80>
}


inline void chip_disable(void)
{
	PORTD |= nCE;
 4b2:	95 9a       	sbi	0x12, 5	; 18
	PORTD &= ~RED;
 4b4:	92 98       	cbi	0x12, 2	; 18
	}

	chip_disable();

	return ERR_OK;		// success
}
 4b6:	c0 50       	subi	r28, 0x00	; 0
 4b8:	df 4f       	sbci	r29, 0xFF	; 255
 4ba:	0f b6       	in	r0, 0x3f	; 63
 4bc:	f8 94       	cli
 4be:	de bf       	out	0x3e, r29	; 62
 4c0:	0f be       	out	0x3f, r0	; 63
 4c2:	cd bf       	out	0x3d, r28	; 61
 4c4:	cf 91       	pop	r28
 4c6:	df 91       	pop	r29
 4c8:	1f 91       	pop	r17
 4ca:	0f 91       	pop	r16
 4cc:	ff 90       	pop	r15
 4ce:	ef 90       	pop	r14
 4d0:	df 90       	pop	r13
 4d2:	cf 90       	pop	r12
 4d4:	bf 90       	pop	r11
 4d6:	af 90       	pop	r10
 4d8:	9f 90       	pop	r9
 4da:	8f 90       	pop	r8
 4dc:	7f 90       	pop	r7
 4de:	6f 90       	pop	r6
 4e0:	5f 90       	pop	r5
 4e2:	4f 90       	pop	r4
 4e4:	3f 90       	pop	r3
 4e6:	2f 90       	pop	r2
 4e8:	08 95       	ret

000004ea <block_read>:


const uint8 block_read()
{
 4ea:	af 92       	push	r10
 4ec:	bf 92       	push	r11
 4ee:	cf 92       	push	r12
 4f0:	df 92       	push	r13
 4f2:	ef 92       	push	r14
 4f4:	ff 92       	push	r15
 4f6:	0f 93       	push	r16
 4f8:	1f 93       	push	r17
	uint32 offset, i = 255;

	// read offset (i.e. base addr. for read)
	offset = serial_read_u32();
 4fa:	ab dd       	rcall	.-1194   	; 0x52 <serial_read_u32>
}


inline void chip_enable(void)
{
	PORTD |= RED;
 4fc:	92 9a       	sbi	0x12, 2	; 18
	PORTD &= ~nCE;
 4fe:	95 98       	cbi	0x12, 5	; 18
 500:	9b 01       	movw	r18, r22
 502:	ac 01       	movw	r20, r24

	chip_enable();

	do
		serial_putc(data_read(offset++));
	while(i--);
 504:	a1 2c       	mov	r10, r1
 506:	61 e0       	ldi	r22, 0x01	; 1
 508:	b6 2e       	mov	r11, r22
 50a:	c1 2c       	mov	r12, r1
 50c:	d1 2c       	mov	r13, r1
 50e:	a2 0e       	add	r10, r18
 510:	b3 1e       	adc	r11, r19
 512:	c4 1e       	adc	r12, r20
 514:	d5 1e       	adc	r13, r21
	offset = serial_read_u32();

	chip_enable();

	do
		serial_putc(data_read(offset++));
 516:	79 01       	movw	r14, r18
 518:	8a 01       	movw	r16, r20
 51a:	08 94       	sec
 51c:	e1 1c       	adc	r14, r1
 51e:	f1 1c       	adc	r15, r1
 520:	01 1d       	adc	r16, r1
 522:	11 1d       	adc	r17, r1
 524:	ca 01       	movw	r24, r20
 526:	b9 01       	movw	r22, r18
 528:	17 de       	rcall	.-978    	; 0x158 <data_read>
}


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
 52a:	5d 9b       	sbis	0x0b, 5	; 11
 52c:	fe cf       	rjmp	.-4      	; 0x52a <block_read+0x40>
	UDR = c;
 52e:	8c b9       	out	0x0c, r24	; 12

	chip_enable();

	do
		serial_putc(data_read(offset++));
	while(i--);
 530:	ea 14       	cp	r14, r10
 532:	fb 04       	cpc	r15, r11
 534:	0c 05       	cpc	r16, r12
 536:	1d 05       	cpc	r17, r13
 538:	19 f0       	breq	.+6      	; 0x540 <block_read+0x56>
 53a:	a8 01       	movw	r20, r16
 53c:	97 01       	movw	r18, r14
 53e:	eb cf       	rjmp	.-42     	; 0x516 <block_read+0x2c>
}


inline void chip_disable(void)
{
	PORTD |= nCE;
 540:	95 9a       	sbi	0x12, 5	; 18
	PORTD &= ~RED;
 542:	92 98       	cbi	0x12, 2	; 18
	while(i--);

	chip_disable();

	return ERR_OK;
}
 544:	8a e5       	ldi	r24, 0x5A	; 90
 546:	1f 91       	pop	r17
 548:	0f 91       	pop	r16
 54a:	ff 90       	pop	r15
 54c:	ef 90       	pop	r14
 54e:	df 90       	pop	r13
 550:	cf 90       	pop	r12
 552:	bf 90       	pop	r11
 554:	af 90       	pop	r10
 556:	08 95       	ret

00000558 <main>:



int main()
{
 558:	1f 93       	push	r17


void bus_init(void)
{
	// Negate nCE, nOE and nWE before the control lines become outputs
	PORTD = nCE | nOE | nWE;
 55a:	80 ee       	ldi	r24, 0xE0	; 224
 55c:	82 bb       	out	0x12, r24	; 18

	// Configure data direction register
	DDRA = 0xff;		// Port A:  D0-D7 - all outputs initially
 55e:	8f ef       	ldi	r24, 0xFF	; 255
 560:	8a bb       	out	0x1a, r24	; 26
	DDRB = 0xff;		// Port B:  A0-A7 - all outputs
 562:	87 bb       	out	0x17, r24	; 23
	DDRC = 0xff;		// Port C:  A8-A15 - all outputs
 564:	84 bb       	out	0x14, r24	; 20
	DDRD = 0xfe;		// Port D:  pd0 input (serial RX) , pd1-pd7 outputs (serial TX, control lines)
 566:	8e ef       	ldi	r24, 0xFE	; 254
 568:	81 bb       	out	0x11, r24	; 17
	bus_init();

	// Configure serial port
	
	// Baud rate = 115200 (UBRR = 3 for 7.3728MHz sysclk)
	UBRRH = 0;
 56a:	10 bc       	out	0x20, r1	; 32
	UBRRL = 3;
 56c:	83 e0       	ldi	r24, 0x03	; 3
 56e:	89 b9       	out	0x09, r24	; 9
	// Baud rate = 230400(UBRR = 1 for 7.3728MHz sysclk)
//	UBRRH = 0;
//	UBRRL = 1;

	// Enable receiver and transmitter; set 8 bits/word, no parity, 1 stop bit
	UCSRB = (1 << RXEN) | (1 << TXEN);
 570:	88 e1       	ldi	r24, 0x18	; 24
 572:	8a b9       	out	0x0a, r24	; 10
	UCSRC = (1 << URSEL) | (1 << UCSZ1) | (1 << UCSZ0);
 574:	86 e8       	ldi	r24, 0x86	; 134
 576:	80 bd       	out	0x20, r24	; 32

	// Main loop.  Wait for instructions.
	PORTD |= GRN;
 578:	93 9a       	sbi	0x12, 3	; 18


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
	UDR = c;
 57a:	1f e3       	ldi	r17, 0x3F	; 63
}


char serial_getc(void)
{
	while(!(UCSRA & (1 << RXC))) ;
 57c:	5f 9b       	sbis	0x0b, 7	; 11
 57e:	fe cf       	rjmp	.-4      	; 0x57c <main+0x24>
	return UDR;
 580:	8c b1       	in	r24, 0x0c	; 12
	// Main loop.  Wait for instructions.
	PORTD |= GRN;
	while(1)
	{
		// Read char from serial port
		switch(serial_getc())
 582:	89 34       	cpi	r24, 0x49	; 73
 584:	d1 f0       	breq	.+52     	; 0x5ba <main+0x62>
 586:	8a 34       	cpi	r24, 0x4A	; 74
 588:	38 f4       	brcc	.+14     	; 0x598 <main+0x40>
 58a:	83 34       	cpi	r24, 0x43	; 67
 58c:	91 f0       	breq	.+36     	; 0x5b2 <main+0x5a>
 58e:	85 34       	cpi	r24, 0x45	; 69
 590:	51 f0       	breq	.+20     	; 0x5a6 <main+0x4e>
 592:	8f 33       	cpi	r24, 0x3F	; 63
 594:	31 f5       	brne	.+76     	; 0x5e2 <main+0x8a>
 596:	1f c0       	rjmp	.+62     	; 0x5d6 <main+0x7e>
 598:	82 35       	cpi	r24, 0x52	; 82
 59a:	b1 f0       	breq	.+44     	; 0x5c8 <main+0x70>
 59c:	86 35       	cpi	r24, 0x56	; 86
 59e:	b1 f0       	breq	.+44     	; 0x5cc <main+0x74>
 5a0:	80 35       	cpi	r24, 0x50	; 80
 5a2:	f9 f4       	brne	.+62     	; 0x5e2 <main+0x8a>
 5a4:	0c c0       	rjmp	.+24     	; 0x5be <main+0x66>
		{
			case 'E':		// E = erase sector
				// read sector num
				while(!(UCSRA & (1 << RXC))) ;
 5a6:	5f 9b       	sbis	0x0b, 7	; 11
 5a8:	fe cf       	rjmp	.-4      	; 0x5a6 <main+0x4e>
				report_status(sector_erase());
 5aa:	a7 de       	rcall	.-690    	; 0x2fa <sector_erase>
}


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
 5ac:	5d 9b       	sbis	0x0b, 5	; 11
 5ae:	fe cf       	rjmp	.-4      	; 0x5ac <main+0x54>
 5b0:	09 c0       	rjmp	.+18     	; 0x5c4 <main+0x6c>
				while(!(UCSRA & (1 << RXC))) ;
				report_status(sector_erase());
				break;

			case 'C':		// C = erase chip
				report_status(chip_erase());
 5b2:	74 de       	rcall	.-792    	; 0x29c <chip_erase>
}


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
 5b4:	5d 9b       	sbis	0x0b, 5	; 11
 5b6:	fe cf       	rjmp	.-4      	; 0x5b4 <main+0x5c>
 5b8:	05 c0       	rjmp	.+10     	; 0x5c4 <main+0x6c>
			case 'C':		// C = erase chip
				report_status(chip_erase());
				break;

			case 'I':		// I = identify
				chip_id();
 5ba:	5f de       	rcall	.-834    	; 0x27a <chip_id>
 5bc:	df cf       	rjmp	.-66     	; 0x57c <main+0x24>
				break;

			case 'P':		// P = program
				report_status(block_program());
 5be:	0b df       	rcall	.-490    	; 0x3d6 <block_program>
}


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
 5c0:	5d 9b       	sbis	0x0b, 5	; 11
 5c2:	fe cf       	rjmp	.-4      	; 0x5c0 <main+0x68>
	UDR = c;
 5c4:	8c b9       	out	0x0c, r24	; 12
 5c6:	da cf       	rjmp	.-76     	; 0x57c <main+0x24>
			case 'P':		// P = program
				report_status(block_program());
				break;

			case 'R':		// R = read block
			 	block_read();
 5c8:	90 df       	rcall	.-224    	; 0x4ea <block_read>
 5ca:	d8 cf       	rjmp	.-80     	; 0x57c <main+0x24>
				break;

			case 'V':		// V = version
				serial_write(SOFTWARE_VERSION, SOFTWARE_VERSION_LEN);
 5cc:	81 e7       	ldi	r24, 0x71	; 113
 5ce:	90 e0       	ldi	r25, 0x00	; 0
 5d0:	64 e0       	ldi	r22, 0x04	; 4
 5d2:	70 e0       	ldi	r23, 0x00	; 0
 5d4:	04 c0       	rjmp	.+8      	; 0x5de <main+0x86>
				break;

			case '?':
				serial_write(PROGRAMMER_IDENTITY, PROGRAMMER_IDENTITY_LEN);
 5d6:	86 e7       	ldi	r24, 0x76	; 118
 5d8:	90 e0       	ldi	r25, 0x00	; 0
 5da:	65 e0       	ldi	r22, 0x05	; 5
 5dc:	70 e0       	ldi	r23, 0x00	; 0
 5de:	9d dd       	rcall	.-1222   	; 0x11a <serial_write>
 5e0:	cd cf       	rjmp	.-102    	; 0x57c <main+0x24>
}


void serial_putc(const char c)
{
	while(!(UCSRA & (1 << UDRE))) ;
 5e2:	5d 9b       	sbis	0x0b, 5	; 11
 5e4:	fe cf       	rjmp	.-4      	; 0x5e2 <main+0x8a>
	UDR = c;
 5e6:	1c b9       	out	0x0c, r17	; 12
 5e8:	c9 cf       	rjmp	.-110    	; 0x57c <main+0x24>

000005ea <_exit>:
 5ea:	f8 94       	cli

000005ec <__stop_program>:
 5ec:	ff cf       	rjmp	.-2      	; 0x5ec <__stop_program>
