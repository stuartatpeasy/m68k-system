/*
    makemap.c: build symbol table in binary format

    Part of ayumos


    (c) Stuart Wallace, August 2015.

    This program reads a symbol list in the format generated by the "nm" (1) tool and writes the
    symbols out in a binary format (see below for format description).  By default it reads from
    stdin and writes to stdout, but input and output files may optionally be specified, e.g.

        makemap [<input_file> [<output_file>]]

    TODO change record format: don't zero-terminate symbol names; modify "len" field such that it
    indicates the length of the symbol name.  Length of the whole record can then be deduced from
    this.
*/

#include <error.h>
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>

#define LINE_BUF_LEN    (512)
#define MAX_NAME_LEN    (256)

/* Program exit codes */
#define E_SUCCESS       (0)     /* Success exit code            */
#define E_SYNTAX        (1)     /* Command-line syntax error    */
#define E_FILE          (2)     /* File create/open error       */
#define E_IO            (3)     /* Read/write failed            */
#define E_MALLOC        (4)     /* Memory allocation failed     */

/*
    Format of entries in an embedded symbol table:

        <addr>  4 bytes     symbol address
        <type>  1 byte      symbol type
        <len>   1 byte      length of this entire record
        <name>  var         zero-terminated name of symbol
    
    Entries are padded such that their total length is a multiple of four bytes.  The symbol table
    is terminated by an entry in which all fields are 0.
*/


enum symtype
{
    EXT_BSS  = 'B',     /* The symbol is in the uninitialized data section (known as BSS). */
    INT_BSS  = 'b',
    EXT_DATA = 'D',     /* Initialised data (.data section) */
    INT_DATA = 'd',
    EXT_RO   = 'R',     /* Read-only (.rodata*) */
    INT_RO   = 'r',
    EXT_TEXT = 'T',     /* Text (code) section (.text) */
    INT_TEXT = 't'
};

typedef enum symtype symtype_t;

/* This struct will be tail-padded with \0s so that its size is a multiple of four bytes */
struct symentry
{
    uint32_t    addr;
    uint8_t     type;
    uint8_t     len;
    char        name;       /* First character of name, a zero-terminated string */
} __attribute__((packed));

typedef struct symentry symentry_t;


/*
    checked_fputc() - a version of fputc() which bails out on error.
*/
int checked_fputc(int c, FILE *stream)
{
    int ret;

    ret = fputc(c, stream);
    if(ret == EOF)
        error(E_IO, errno, "Write failed");

    return ret;
}


int main(int argc, char **argv)
{
    char name[MAX_NAME_LEN], line_buf[LINE_BUF_LEN];
    FILE *fp_in, *fp_out;
    int ret, line;
    const int num_input_fields = 3;     /* Number of fields in nm's output */
    void *eot_buf;                      /* Buffer to hold end-of-table (EOT) marker */

    /* Size of end-of-table (EOT) marker, rounded up to the nearest four bytes */
    const size_t eot_marker_len = (sizeof(symentry_t) + 3) & ~3;

    fp_in = stdin;
    fp_out = stdout;

    switch(argc)
    {
        case 3:                     /* syntax: <appname> <input_file> <output_file> */
            fp_out = fopen(argv[2], "w");
            if(!fp_out)
                error(E_FILE, errno, "Unable to open output file '%s'", argv[2]);

            /* fall through */
        case 2:                     /* syntax: <appname> <input_file>; implicit write to stdout */
            fp_in = fopen(argv[1], "r");
            if(!fp_in)
                error(E_FILE, errno, "Unable to open input file '%s'", argv[1]);

        case 1:                     /* implicit read from stdin and write to stdout */
            break;

        default:
            error(E_SYNTAX, 0, "Syntax: %s [<input_file> [<output_file>]]", argv[0]);
    }
    
    /*
        Allocate buffer for end-of-table (EOT) marker.  This marker has all fields set to zero, so
        calloc() both allocates and initialises the marker.
    */
    eot_buf = (char *) calloc(1, eot_marker_len);
    if(eot_buf == NULL)
        error(E_MALLOC, errno, "Failed to allocate %d bytes", (int) eot_marker_len);

    line = 1;

    do
    {
        char *p;
        uint32_t len, padding;
        symentry_t sym;
        
        /*
            Format of the output of *nm <obj_file>:
        
                00f00be4 T ata_control
                [...]

            Longest symbol name allowable by our map format (which stores record length in a uint8)
            is:

                252         <-- longest multiple-of-four representable in an unsigned 8-bit int
                - 4         <-- sizeof(u32) address field
                - 1         <-- sizeof(symtype_t) type field
                - 1         <-- sizeof(u8) length field
                - 1         <-- terminating '\0' at end of name
              = 245 bytes
        */

        if(fgets(line_buf, sizeof(line_buf) / sizeof(line_buf[0]), fp_in) != NULL)
        {
            bzero(name, sizeof(name) / sizeof(name[0]));

            ret = sscanf(line_buf, "%08x %c %245s\n", &sym.addr, (char *) &sym.type, &name[0]);
            if(ret == num_input_fields)
            {
                if(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
                    sym.addr = __builtin_bswap32(sym.addr);

                len = sizeof(sym.addr) + sizeof(sym.type) + sizeof(sym.len) + strlen(name) + 1; 
                padding = (4 - (len & 3)) & 3;

                sym.len = len + padding;
            
                for(p = (char *) &sym; p < &sym.name; ++p)
                    checked_fputc(*p, fp_out);

                for(p = name; *p; ++p)
                    checked_fputc(*p, fp_out);
                fputc(0, fp_out);

                for(; padding--;)
                    checked_fputc(0, fp_out);
            }
        }
        ++line;
    } while(!feof(fp_in));

    /* Write end-of-table marker */
    if(fwrite(eot_buf, eot_marker_len, 1, fp_out) < 1)
        error(E_IO, errno, "Failed to write end-of-symbol-table marker");

    fflush(fp_out);
    free(eot_buf);

    return 0;
}
